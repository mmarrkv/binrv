%%

%%The larva code below encode the following 2 regular expressions:

%%Assumes subtraces already in place as per taint inference policy based on taint_vars set

%%[SSL_ImportFD()ret:][]*[PR_Connect()fd:][]*[SSL_AuthCertificateComplete()ret:!0x0][]*[PK11_Encrypt()] → REJECT

%%[SSL_ImportFD()ret:][]*[PR_Connect()fd:][]*[SSL_AuthCertificateComplete()ret:!0x0]![PK11_Encrypt()]*[PR_Close()fd:] → ACCEPT

%%

Imports{
  
  import elements.MethodCall;
  import elements.EndOfTrace;
  import java.util.Map;
}


Global{
  
    Variables {
      MethodCall mcParent;
    }

    Events {
      sslimport() = {MethodCall mc.call(String n,*,*)} 
      filter {n.equals("SSL_ImportFD")}
      
      prconnect() = {MethodCall mc.call(String n,*,*)} 
      filter {n.equals("PR_Connect")}
             
      sslauthcertcompl() = {MethodCall mc.call(String n,*, Map params )} 
      filter {n.equals("SSL_AuthCertificateComplete") && !((String)params.get("err")).equals("0x0")}
      
      destroypk(mc) = {MethodCall mc.call(String n,*,*)} 
      filter {n.equals("SECKEY_DestroyPrivateKey")}
      
      
      pk11encrypt(mc) = {MethodCall mc.call(String n,*,*)} 
      filter {n.equals("PK11_Encrypt")}

      prclose(mc) = {MethodCall mc.call(String n,*,*)} 
      filter {n.equals("PR_Close")} 
      
      eot() = {EndOfTrace eot.call()}
      
  }

   Property wrongcert {

     States {
       Accepting { ok }
       Bad       { wrongcert }   
       Normal    { import 
                   connect 
                   sslauthcertcompl
                   close }
       Starting  { start }
     }

     Transitions {
       start -> import               [sslimport]
       import -> connect             [prconnect]
       connect -> sslauthcertcompl   [sslauthcertcompl]
       sslauthcertcompl -> close     [prclose\\mcParent=mc;]
       close -> ok 					 [destroypk\mc.hasParent(mcParent)]

       sslauthcertcompl -> wrongcert [eot]
       close -> wrongcert            [eot]
     }
   
  } 
}